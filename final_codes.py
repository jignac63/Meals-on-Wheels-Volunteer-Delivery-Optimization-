# -*- coding: utf-8 -*-
"""Final Codes.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1kLZg691s3WxtsTHDk1YpErkhi4CITW-r

Approach 1: Optimization (Weighted Sum Method)
"""

import pandas as pd

# Load the datasets
delivery_data = pd.read_csv('/content/Cleaned_Meal_Delivery-opencage-geocoded-3458342178 4-2.csv')
parking_data = pd.read_csv('/content/Parking_consolidated-opencage-geocoded-2314883047.csv')

# Display the first few rows to verify the data
display(delivery_data.head())
display(parking_data.head())

pip install geopy

pip install pulp

pip install folium

pip install pandas

pip install matplotlib

from pulp import LpMinimize, LpProblem, LpVariable, lpSum
from geopy.distance import geodesic

# Get delivery and parking locations
delivery_locations = list(zip(delivery_data['Latitude'], delivery_data['Longitude']))
parking_locations = list(zip(parking_data['Latitude'], parking_data['Longitude']))

# Define the weights (can be adjusted)
w1, w2 = 0.7, 0.3  # 70% priority to walking distance, 30% to parking cost

# Distance Matrix Calculation
def calculate_distance_matrix(parking_locations, delivery_locations):
    distance_matrix = []
    for park in parking_locations:
        row = []
        for delivery in delivery_locations:
            row.append(geodesic(park, delivery).meters)
        distance_matrix.append(row)
    return distance_matrix

# Calculate Distance Matrix
walking_distance_matrix = calculate_distance_matrix(parking_locations, delivery_locations)

# Multi-Objective Model Definition
model = LpProblem("Multi_Objective_Optimization", LpMinimize)

# Decision Variables
X = LpVariable.dicts("X", [(i, j) for i in range(len(parking_locations)) for j in range(len(delivery_locations))], 0, 1, cat="Binary")
Y = LpVariable.dicts("Y", [i for i in range(len(parking_locations))], 0, 1, cat="Binary")

# Objective Function
model += w1 * lpSum(walking_distance_matrix[i][j] * X[i, j] for i in range(len(parking_locations)) for j in range(len(delivery_locations)))
model += w2 * lpSum(parking_data.iloc[i]['price'] * Y[i] for i in range(len(parking_locations)))

# Constraints:
# Each delivery location must be covered by at least one parking spot
for j in range(len(delivery_locations)):
    model += lpSum(X[i, j] for i in range(len(parking_locations))) >= 1

# Solve the problem
model.solve()

# Display the status
print(f"Optimization Status: {model.status}")

# Extract optimal routes
optimal_routes = []
for i in range(len(parking_locations)):
    for j in range(len(delivery_locations)):
        if X[i, j].value() == 1:
            optimal_routes.append((parking_locations[i], delivery_locations[j]))

# Extract optimal parking
optimal_parking = []
for i in range(len(parking_locations)):
    if Y[i].value() == 1:
        optimal_parking.append(parking_locations[i])

print("Optimal Routes:", optimal_routes)
print("Optimal Parking Spots:", optimal_parking)

import folium
from folium.plugins import MarkerCluster

# Initialize the map centered around Denver
map_routes = folium.Map(location=[39.7392, -104.9903], zoom_start=12)

# Plot Parking Spots
for coord in optimal_parking:
    folium.Marker(
        location=coord,
        popup=f"Optimal Parking Spot",
        icon=folium.Icon(color='blue', icon='parking')
    ).add_to(map_routes)


# Define colors for different clusters
colors = ['red', 'green', 'orange', 'purple', 'darkred', 'lightred', 'beige', 'darkblue', 'darkgreen', 'cadetblue']
color = colors[0]  # All routes in one color

# Plot the routes and markers
for path in optimal_routes:
    # Starting point (Parking)
    folium.Marker(
        location=path[0],
        popup="Parking Spot",
        icon=folium.Icon(color='blue', icon='parking')
    ).add_to(map_routes)

    # Ending point (Delivery)
    folium.Marker(
        location=path[1],
        popup="Delivery Location",
        icon=folium.Icon(color='red', icon='home')
    ).add_to(map_routes)

    # Draw the path
    folium.PolyLine(locations=[path[0], path[1]], color=color, weight=2.5, opacity=0.7).add_to(map_routes)

# Save the map in Colab workspace
map_routes.save('/content/Multi_Objective_Optimized_Map.html')

from google.colab import files
files.download('/content/Multi_Objective_Optimized_Map.html')

"""Approach 3: Goal Programming for Multi-Objective Optimization"""

pip install geopy

pip install pulp

pip --version

from pulp import LpMinimize, LpProblem, LpVariable, lpSum
from geopy.distance import geodesic
import pandas as pd
import numpy as np

# Load the datasets
delivery_data = pd.read_csv('/content/Cleaned_Meal_Delivery-opencage-geocoded-3458342178 4-2.csv')
parking_data = pd.read_csv('/content/Parking_consolidated-opencage-geocoded-2314883047.csv')

# Get delivery and parking locations
delivery_locations = list(zip(delivery_data['Latitude'], delivery_data['Longitude']))
parking_locations = list(zip(parking_data['Latitude'], parking_data['Longitude']))

# ✅ **Optimized Distance Matrix Calculation**
def calculate_distance_matrix(parking_locations, delivery_locations):
    parking_matrix = np.array(parking_locations)
    delivery_matrix = np.array(delivery_locations)
    distances = np.zeros((len(parking_matrix), len(delivery_matrix)))

    for i, park in enumerate(parking_matrix):
        distances[i] = np.linalg.norm(delivery_matrix - park, axis=1)

    return distances

# Calculate Distance Matrix
walking_distance_matrix = calculate_distance_matrix(parking_locations, delivery_locations)

# ✅ **Optimized Multi-Objective Model Definition**
model = LpProblem("Goal_Programming_Optimization", LpMinimize)

# Decision Variables
X = LpVariable.dicts("X", [(i, j) for i in range(len(parking_locations)) for j in range(len(delivery_locations))], 0, 1, cat="Binary")
Y = LpVariable.dicts("Y", [i for i in range(len(parking_locations))], 0, 1, cat="Binary")

# ✅ **Optimized Deviation Variables for Goal Programming**
d1_plus, d1_minus, d2_plus, d2_minus = [LpVariable(f"d{i}", 0) for i in range(1, 5)]

# ✅ **Goal Constraints: Vectorized for Speed**
model += (
    lpSum(walking_distance_matrix[i, j] * X[i, j] for i in range(len(parking_locations)) for j in range(len(delivery_locations)))
    + d1_minus - d1_plus == 5000  # Example: 5000 meters
)

model += (
    lpSum(parking_data.iloc[i]['price'] * Y[i] for i in range(len(parking_locations)))
    + d2_minus - d2_plus == 100  # Example: $100 budget
)

# ✅ **Objective Function: Minimize deviation from goals**
model += d1_plus + d1_minus + d2_plus + d2_minus

# ✅ **Solve the problem with logging for speed analysis**
model.solve()

# Display the status
print(f"Optimization Status: {model.status}")

# Extract optimal routes
optimal_routes = []
for i in range(len(parking_locations)):
    for j in range(len(delivery_locations)):
        if X[i, j].value() == 1:
            optimal_routes.append((parking_locations[i], delivery_locations[j]))

# Extract optimal parking
optimal_parking = []
for i in range(len(parking_locations)):
    if Y[i].value() == 1:
        optimal_parking.append(parking_locations[i])

print("✅ Optimal Routes Extracted:")
for route in optimal_routes:
    print(f"From Parking: {route[0]} to Delivery: {route[1]}")

print("\n✅ Optimal Parking Spots Selected:")
for spot in optimal_parking:
    print(f"Parking Spot: {spot}")

import folium
from folium.plugins import MarkerCluster

# Initialize the map centered around Denver
map_routes = folium.Map(location=[39.7392, -104.9903], zoom_start=12)

# Define colors for different clusters
color = 'green'

# Plot only the optimal routes and markers
for path in optimal_routes:
    # Starting point (Parking)
    folium.Marker(
        location=path[0],
        popup="Parking Spot",
        icon=folium.Icon(color='blue', icon='parking')
    ).add_to(map_routes)

    # Ending point (Delivery)
    folium.Marker(
        location=path[1],
        popup="Delivery Location",
        icon=folium.Icon(color='red', icon='home')
    ).add_to(map_routes)

    # Draw the path
    folium.PolyLine(locations=[path[0], path[1]], color=color, weight=2.5, opacity=0.7).add_to(map_routes)

# Save the map in Colab workspace
map_routes.save('/content/Goal_Programming_Optimal_Routes_Map.html')

import folium

# Initialize the map centered around Denver
map_routes = folium.Map(location=[39.7392, -104.9903], zoom_start=12)

# Plot only the routes and markers where X[i,j] = 1 and the parking Y[i] = 1
for path in optimal_routes:
    parking_coord = path[0]
    delivery_coord = path[1]

    # Draw the optimal route line
    folium.PolyLine(
        locations=[parking_coord, delivery_coord],
        color='green',
        weight=2.5,
        opacity=0.8
    ).add_to(map_routes)

    # Parking marker
    folium.Marker(
        location=parking_coord,
        popup="Selected Parking Spot",
        icon=folium.Icon(color='blue', icon='parking')
    ).add_to(map_routes)

    # Delivery marker
    folium.Marker(
        location=delivery_coord,
        popup="Delivery Location",
        icon=folium.Icon(color='red', icon='home')
    ).add_to(map_routes)

# Save the map in Colab
map_routes.save('/content/Selected_Optimal_Routes_Map.html')

"""Approach 3: Constraint Method

Final Analysis
"""

import pandas as pd

# Load the datasets
parking_data = pd.read_excel('/content/parking_geocoded.xlsx')
delivery_data = pd.read_excel('/content/delivery_geocoded.xlsx')

# Display the data for verification
print("Parking Data:\n", parking_data.head())
print("\nDelivery Data:\n", delivery_data.head())

# Extracting coordinates
delivery_coordinates = delivery_data[['Latitude', 'Longitude']].values.tolist()
parking_coordinates = parking_data[['Latitude', 'Longitude']].values.tolist()

print(f"Total Delivery Locations: {len(delivery_coordinates)}")
print(f"Total Parking Locations: {len(parking_coordinates)}")

# Create a DataFrame to store cluster assignments
cluster_assignments = delivery_data[['Full Address', 'Latitude', 'Longitude', 'Cluster']].copy()
cluster_assignments['Assigned_Parking'] = None

from haversine import haversine

# Loop through each cluster and find the nearest parking spot
for cluster in cluster_assignments['Cluster'].unique():
    # Get the cluster center
    cluster_center = kmeans.cluster_centers_[cluster]

    # Compute distances to all parking spots
    distances = [haversine(cluster_center, (row['Latitude'], row['Longitude'])) for idx, row in parking_data.iterrows()]

    # Find the nearest parking spot
    nearest_parking_idx = distances.index(min(distances))

    # Assign the nearest parking address to the cluster
    cluster_assignments.loc[cluster_assignments['Cluster'] == cluster, 'Assigned_Parking'] = parking_data.loc[nearest_parking_idx, 'Full Address']
    cluster_assignments.loc[cluster_assignments['Cluster'] == cluster, 'Parking_Cost'] = parking_data.loc[nearest_parking_idx, 'price']

output_path = '/content/Clustered_Parking_Assignment.csv'
cluster_assignments.to_csv(output_path, index=False)
print(f"✅ File saved successfully to {output_path}")

!pip install pulp
!pip install haversine

import pulp
import pandas as pd
import numpy as np
from haversine import haversine, Unit

# Load Data
delivery_data = pd.read_excel('/content/delivery_geocoded.xlsx')
parking_data = pd.read_excel('/content/parking_geocoded.xlsx')

# Extract coordinates
delivery_coordinates = delivery_data[['Latitude', 'Longitude']].values.tolist()
parking_coordinates = parking_data[['Latitude', 'Longitude']].values.tolist()
parking_costs = parking_data['price'].values.tolist()

# Calculate the walking distance matrix
distance_matrix = []
for delivery in delivery_coordinates:
    row = [haversine(delivery, parking, unit=Unit.METERS) for parking in parking_coordinates]
    distance_matrix.append(row)

# Number of deliveries and parking spots
num_deliveries = len(delivery_coordinates)
num_parking = len(parking_coordinates)

# Create a PuLP problem
problem = pulp.LpProblem("Parking_Optimization", pulp.LpMinimize)

# Decision Variables
X = pulp.LpVariable.dicts("X", (range(num_deliveries), range(num_parking)), cat="Binary")
Y = pulp.LpVariable.dicts("Y", range(num_parking), cat="Binary")

# Objective Function: Minimize Cost (Parking + Walking Distance)
problem += pulp.lpSum([X[i][j] * distance_matrix[i][j] for i in range(num_deliveries) for j in range(num_parking)]) + \
           pulp.lpSum([Y[j] * parking_costs[j] for j in range(num_parking)])

# Constraints:
# Each delivery must be assigned to exactly one parking spot
for i in range(num_deliveries):
    problem += pulp.lpSum([X[i][j] for j in range(num_parking)]) == 1

# If a delivery is assigned to a parking spot, that spot must be used
for i in range(num_deliveries):
    for j in range(num_parking):
        problem += X[i][j] <= Y[j]

# Solve the problem
problem.solve()

# Output the results
assignments = []
for i in range(num_deliveries):
    for j in range(num_parking):
        if pulp.value(X[i][j]) == 1:
            assignments.append({
                'Delivery Address': delivery_data.loc[i, 'Full Address'],
                'Assigned Parking': parking_data.loc[j, 'Full Address'],
                'Parking Cost': parking_data.loc[j, 'price'],
                'Walking Distance (m)': distance_matrix[i][j]
            })


# Save the optimized assignments to a CSV file in Colab's local storage
assignments_df.to_csv('/content/Optimized_Parking_Assignments.csv', index=False)
print("✅ Optimized assignments saved to Optimized_Parking_Assignments.csv")

# Load the delivery and parking data
delivery_data = pd.read_excel('/content/delivery_geocoded.xlsx')
parking_data = pd.read_excel('/content/parking_geocoded.xlsx')
assignments_df = pd.read_csv('/content/Optimized_Parking_Assignments.csv')

# Initialize the folium map
optimal_map = folium.Map(location=[39.7392, -104.9903], zoom_start=12)

assignments_df.columns

import folium

# Initialize the map
optimal_map = folium.Map(location=[39.7392, -104.9903], zoom_start=12)

# Add delivery locations to the map
for idx, row in assignments_df.iterrows():
    delivery_address = row['Delivery Address']

    # Find the corresponding delivery coordinates
    delivery_location = delivery_data[delivery_data['Full Address'] == delivery_address]

    if not delivery_location.empty:
        lat = delivery_location.iloc[0]['Latitude']
        lon = delivery_location.iloc[0]['Longitude']

        # Plot the delivery location
        folium.Marker(
            location=[lat, lon],
            popup=f"Delivery: {delivery_address}",
            icon=folium.Icon(color='blue', icon='home')
        ).add_to(optimal_map)

# Add parking locations to the map
for idx, row in assignments_df.iterrows():
    parking_address = row['Assigned Parking']

    # Find the corresponding parking coordinates
    parking_location = parking_data[parking_data['Full Address'] == parking_address]

    if not parking_location.empty:
        lat = parking_location.iloc[0]['Latitude']
        lon = parking_location.iloc[0]['Longitude']
        cost = parking_location.iloc[0]['price']

        # Plot the parking location
        folium.Marker(
            location=[lat, lon],
            popup=f"Parking: {parking_address} | Cost: ${cost}",
            icon=folium.Icon(color='green', icon='car')
        ).add_to(optimal_map)

# Save the map as HTML directly in Colab
optimal_map.save('/content/Optimal_Parking_Assignment_Map.html')
print("✅ Map saved as 'Optimal_Parking_Assignment_Map.html'")

import folium
from folium.plugins import MarkerCluster
import pandas as pd

# Load the data
assignments_df = pd.read_csv('/content/Optimized_Parking_Assignments.csv')
parking_data = pd.read_csv('/content/Parking_geocoded.csv')
delivery_data = pd.read_csv('/content/Delivery_geocoded.csv')

# Initialize the map centered around Denver
m = folium.Map(location=[39.7392, -104.9903], zoom_start=12)

# Marker Clusters
delivery_cluster = MarkerCluster(name="Delivery Locations").add_to(m)
parking_cluster = MarkerCluster(name="Parking Locations").add_to(m)

# Add Delivery Locations to the map
for idx, row in assignments_df.iterrows():
    delivery_row = delivery_data[delivery_data['Address'] == row['Delivery Address']].iloc[0]
    folium.Marker(
        location=[delivery_row['Latitude'], delivery_row['Longitude']],
        popup=f"Delivery Address: {row['Delivery Address']}<br>Assigned Parking: {row['Assigned Parking']}<br>Walking Distance: {row['Walking Distance (m)']}m",
        icon=folium.Icon(color='blue', icon='home', prefix='fa')
    ).add_to(delivery_cluster)

# Add Parking Locations to the map
for idx, row in assignments_df.iterrows():
    parking_row = parking_data[parking_data['Full Address'] == row['Assigned Parking']].iloc[0]
    folium.Marker(
        location=[parking_row['Latitude'], parking_row['Longitude']],
        popup=f"Parking Address: {row['Assigned Parking']}<br>Cost: ${row['Parking Cost']}",
        icon=folium.Icon(color='green', icon='car', prefix='fa')
    ).add_to(parking_cluster)

# Draw lines between optimal parking spots and their deliveries
for idx, row in assignments_df.iterrows():
    delivery_row = delivery_data[delivery_data['Address'] == row['Delivery Address']].iloc[0]
    parking_row = parking_data[parking_data['Full Address'] == row['Assigned Parking']].iloc[0]

    folium.PolyLine(
        locations=[(parking_row['Latitude'], parking_row['Longitude']), (delivery_row['Latitude'], delivery_row['Longitude'])],
        color='gray',
        weight=2,
        opacity=0.7,
        tooltip=f"{row['Delivery Address']} → {row['Assigned Parking']}"
    ).add_to(m)

# Save the map to HTML
m.save('/content/Optimal_Parking_Delivery_Map.html')
print("✅ Map saved as Optimal_Parking_Delivery_Map.html")

# Display the map
m

import folium
from folium.plugins import MarkerCluster
import pandas as pd

# Load the data
assignments_df = pd.read_csv('/content/Optimized_Parking_Assignments.csv')
parking_data = pd.read_excel('/content/parking_geocoded.xlsx')
delivery_data = pd.read_excel('/content/delivery_geocoded.xlsx')

# Initialize the map centered around Denver
m = folium.Map(location=[39.7392, -104.9903], zoom_start=12)

# Marker Clusters
delivery_cluster = MarkerCluster(name="Delivery Locations").add_to(m)
parking_cluster = MarkerCluster(name="Parking Locations").add_to(m)

# Add Delivery Locations to the map
for idx, row in assignments_df.iterrows():
    delivery_row = delivery_data[delivery_data['Full Address'] == row['Delivery Address']].iloc[0]
    folium.Marker(
        location=[delivery_row['Latitude'], delivery_row['Longitude']],
        popup=f"Delivery Address: {row['Delivery Address']}<br>Assigned Parking: {row['Assigned Parking']}<br>Walking Distance: {row['Walking Distance (m)']}m",
        icon=folium.Icon(color='blue', icon='home', prefix='fa')
    ).add_to(delivery_cluster)

# Add Parking Locations to the map
for idx, row in assignments_df.iterrows():
    parking_row = parking_data[parking_data['Full Address'] == row['Assigned Parking']].iloc[0]
    folium.Marker(
        location=[parking_row['Latitude'], parking_row['Longitude']],
        popup=f"Parking Address: {row['Assigned Parking']}<br>Cost: ${row['Parking Cost']}",
        icon=folium.Icon(color='green', icon='car', prefix='fa')
    ).add_to(parking_cluster)

# Draw lines between optimal parking spots and their deliveries
for idx, row in assignments_df.iterrows():
    delivery_row = delivery_data[delivery_data['Full Address'] == row['Delivery Address']].iloc[0]
    parking_row = parking_data[parking_data['Full Address'] == row['Assigned Parking']].iloc[0]

    folium.PolyLine(
        locations=[(parking_row['Latitude'], parking_row['Longitude']), (delivery_row['Latitude'], delivery_row['Longitude'])],
        color='gray',
        weight=2,
        opacity=0.7,
        tooltip=f"{row['Delivery Address']} → {row['Assigned Parking']}"
    ).add_to(m)

# Save the map to HTML
m.save('/content/Optimal_Parking_Delivery_Map.html')
print("✅ Map saved as Optimal_Parking_Delivery_Map.html")